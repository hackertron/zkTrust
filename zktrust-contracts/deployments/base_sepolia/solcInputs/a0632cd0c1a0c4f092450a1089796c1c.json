{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/ReviewRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./ReviewStorage.sol\"; // Import the updated ReviewStorage\n\n/**\n * @title ReviewRegistry\n * @notice Manages product/reviewer/service registries and orchestrates review submissions.\n * @dev Assumes cryptographic proof was verified on-chain via SDK *before* calling submitReview.\n *      Relies on ReviewStorage contract to check nullifier uniqueness. Ownable for admin functions.\n */\ncontract ReviewRegistry is Ownable {\n    // Address of the ReviewStorage contract\n    ReviewStorage public storageContract;\n\n    // Counter for total registered products\n    uint256 public productCount;\n\n    // Struct definitions\n    struct Product {\n        bytes32 id; // Unique ID (e.g., hash of identifier)\n        string name; // Product name\n        string manufacturer; // Product manufacturer\n        uint256 totalRating; // Sum of all ratings\n        uint256 reviewCount; // Number of reviews received\n    }\n\n    struct Reviewer {\n        address addr; // Reviewer's wallet address\n        uint256 reputation; // Simple reputation score\n        uint256 reviewCount; // Number of reviews submitted\n    }\n\n    struct Service {\n        string name; // Name of the service (e.g., \"Gumroad\", \"Luma\")\n        string domain; // Associated domain for the service\n        bool isSupported; // Flag if service is currently supported (owner-managed)\n    }\n\n    // Mappings\n    mapping(bytes32 => Product) public products;\n    mapping(address => Reviewer) public reviewers;\n    mapping(string => Service) public services; // Maps service name to Service struct\n\n    // Events\n    event ProductRegistered(\n        bytes32 indexed productId,\n        string name,\n        string manufacturer\n    );\n    event ServiceAdded(string name, string domain);\n    event ServiceRemoved(string name);\n    event StorageContractUpdated(address newStorageAddress); // Renamed event\n    event ReviewSubmitted(\n        uint256 indexed reviewId,\n        bytes32 indexed productId,\n        address indexed reviewer,\n        uint8 rating\n    );\n\n    /**\n     * @dev Constructor sets the initial owner and the essential storage contract address.\n     * @param _storage Address of the deployed ReviewStorage contract.\n     */\n    constructor(address _storage) Ownable(msg.sender) {\n        require(_storage != address(0), \"Invalid storage address\");\n        storageContract = ReviewStorage(_storage);\n    }\n\n    /**\n     * @dev Registers a new product. Can be called by anyone.\n     *      If a product gets its first review via submitReview before being registered,\n     *      it will be auto-registered with default details.\n     * @param productId Unique identifier for the product.\n     * @param name Product name.\n     * @param manufacturer Product manufacturer.\n     */\n    function registerProduct(\n        bytes32 productId,\n        string calldata name,\n        string calldata manufacturer\n    ) external {\n        require(\n            products[productId].id == bytes32(0),\n            \"Product already registered\"\n        );\n\n        productCount++;\n        products[productId] = Product({\n            id: productId,\n            name: name,\n            manufacturer: manufacturer,\n            totalRating: 0,\n            reviewCount: 0\n        });\n\n        emit ProductRegistered(productId, name, manufacturer);\n    }\n\n    /**\n     * @dev Gets product information including average rating.\n     * @param productId ID of the product.\n     * @return name Product name.\n     * @return manufacturer Product manufacturer.\n     * @return averageRating Average rating (0 if no reviews).\n     * @return reviewCount Number of reviews.\n     */\n    function getProduct(\n        bytes32 productId\n    )\n        external\n        view\n        returns (\n            string memory name,\n            string memory manufacturer,\n            uint256 averageRating,\n            uint256 reviewCount\n        )\n    {\n        Product storage product = products[productId];\n        if (product.id == bytes32(0)) {\n            // Return defaults if product not explicitly or implicitly registered\n            return (\"Unknown Product\", \"Unknown Manufacturer\", 0, 0);\n        }\n\n        uint256 avgRating = 0;\n        if (product.reviewCount > 0) {\n            avgRating = product.totalRating / product.reviewCount;\n        }\n        return (\n            product.name,\n            product.manufacturer,\n            avgRating,\n            product.reviewCount\n        );\n    }\n\n    /**\n     * @dev Gets reviewer information.\n     * @param reviewerAddress Address of the reviewer.\n     * @return reputation Reviewer's reputation score.\n     * @return reviewCount Number of reviews submitted by the reviewer.\n     */\n    function getReviewer(\n        address reviewerAddress\n    ) external view returns (uint256 reputation, uint256 reviewCount) {\n        Reviewer storage reviewer = reviewers[reviewerAddress];\n        // Returns (0, 0) if reviewer not found, which is the default struct state\n        return (reviewer.reputation, reviewer.reviewCount);\n    }\n\n    /**\n     * @dev Adds a new supported service - only owner.\n     * @param name Service name (used as key).\n     * @param domain Service domain.\n     */\n    function addService(\n        string calldata name,\n        string calldata domain\n    ) external onlyOwner {\n        require(bytes(name).length > 0, \"Name cannot be empty\");\n        require(bytes(domain).length > 0, \"Domain cannot be empty\");\n        require(!services[name].isSupported, \"Service already supported\");\n\n        services[name] = Service({\n            name: name,\n            domain: domain,\n            isSupported: true\n        });\n\n        emit ServiceAdded(name, domain);\n    }\n\n    /**\n     * @dev Removes a service from the supported list (marks as unsupported) - only owner.\n     * @param name Name of the service to remove.\n     */\n    function removeService(string calldata name) external onlyOwner {\n        require(services[name].isSupported, \"Service not supported\");\n        services[name].isSupported = false;\n        emit ServiceRemoved(name);\n    }\n\n    /**\n     * @dev Checks if a service is currently marked as supported.\n     * @param name Name of the service to check.\n     * @return True if the service is supported, false otherwise.\n     */\n    function isServiceSupported(\n        string calldata name\n    ) external view returns (bool) {\n        return services[name].isSupported;\n    }\n\n    /**\n     * @dev Updates the storage contract address - only owner.\n     * @param storageAddr New storage contract address.\n     */\n    function updateStorageContract(address storageAddr) external onlyOwner {\n        // Renamed function\n        require(storageAddr != address(0), \"Invalid storage address\");\n        storageContract = ReviewStorage(storageAddr);\n        emit StorageContractUpdated(storageAddr); // Renamed event\n    }\n\n    /**\n     * @dev Submits review data after proof has been verified via SDK.\n     * @notice Requires proof to be verified on-chain using the SDK *before* this call.\n     * @param nullifier Unique identifier to prevent duplicate reviews (checked by storage contract).\n     * @param productId ID of the product being reviewed.\n     * @param content Review text content.\n     * @param rating Numerical rating (1-5).\n     * @param serviceName Name of the service (e.g., \"Gumroad\").\n     * @return The ID of the new review stored in ReviewStorage.\n     */\n    function submitReview(\n        bytes32 nullifier,\n        bytes32 productId,\n        string calldata content,\n        uint8 rating,\n        string calldata serviceName\n    ) external returns (uint256) {\n        // Step 1: Cryptographic verification is assumed to be completed via SDK before this call.\n\n        // Step 2: Add the review to storage, passing the original user's address (msg.sender)\n        // The storage contract will perform the nullifier check.\n        uint256 reviewId = storageContract.addReview(\n            productId,\n            msg.sender, // Pass the original caller's address\n            content,\n            rating,\n            nullifier,\n            serviceName\n        );\n\n        // Step 3: Update product statistics. Auto-register if product is new.\n        Product storage product = products[productId];\n        if (product.id == bytes32(0)) {\n            // Product doesn't exist, auto-register it\n            productCount++;\n            products[productId] = Product({\n                id: productId,\n                name: \"Unknown Product\", // Default name, can be updated later if needed\n                manufacturer: \"Unknown Manufacturer\", // Default manufacturer\n                totalRating: rating,\n                reviewCount: 1\n            });\n            // Optional: Emit ProductRegistered here if needed for off-chain listeners\n            // emit ProductRegistered(productId, \"Unknown Product\", \"Unknown Manufacturer\");\n        } else {\n            // Product exists, update stats\n            product.totalRating += rating;\n            product.reviewCount += 1;\n        }\n\n        // Step 4: Update reviewer statistics\n        Reviewer storage reviewer = reviewers[msg.sender];\n        if (reviewer.addr == address(0)) {\n            // First review from this address\n            reviewer.addr = msg.sender;\n            reviewer.reviewCount = 1;\n            reviewer.reputation = 1; // Start reputation\n        } else {\n            // Existing reviewer\n            reviewer.reviewCount += 1;\n            reviewer.reputation += 1; // Simple reputation increment, can be made more complex\n        }\n\n        // Step 5: Emit event for successful submission\n        emit ReviewSubmitted(reviewId, productId, msg.sender, rating);\n\n        return reviewId;\n    }\n\n    /**\n     * @dev Public view function to check nullifier status by querying the storage contract.\n     * @param nullifier The nullifier to check.\n     * @return isUsed Whether the nullifier has been used in storage.\n     */\n    function isNullifierUsed(\n        bytes32 nullifier\n    ) external view returns (bool isUsed) {\n        // Delegate the check to the storage contract's public mapping\n        return storageContract.usedNullifiers(nullifier);\n    }\n}\n"
    },
    "contracts/ReviewStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title ReviewStorage\n * @notice Stores reviews submitted through the ReviewRegistry and enforces nullifier uniqueness.\n * @dev Assumes cryptographic proof validity was checked before registry interaction.\n *      Ownable for potential future administrative functions (e.g., migration).\n */\ncontract ReviewStorage is Ownable {\n    // Total number of reviews stored\n    uint256 public reviewCount;\n\n    // Review struct\n    struct Review {\n        uint256 id; // Unique ID for the review\n        bytes32 productId; // ID of the product reviewed\n        address reviewer; // Address of the original reviewer\n        string content; // Text content of the review\n        uint8 rating; // Numerical rating (1-5)\n        bytes32 nullifier; // Unique identifier from the ZK proof to prevent duplicates\n        uint256 timestamp; // Timestamp of submission\n        string serviceName; // Name of the service/platform where interaction occurred (e.g., \"Gumroad\")\n    }\n\n    // --- Mappings ---\n    // Maps review ID to Review struct\n    mapping(uint256 => Review) public reviews;\n    // Maps product ID to an array of review IDs for that product\n    mapping(bytes32 => uint256[]) public productReviews;\n    // Maps reviewer address to an array of review IDs submitted by that reviewer\n    mapping(address => uint256[]) public reviewerReviews;\n    // Maps nullifier hash to boolean indicating if it has been used\n    // Public visibility allows external checks (e.g., by ReviewRegistry or frontend)\n    mapping(bytes32 => bool) public usedNullifiers;\n\n    // --- Events ---\n    event ReviewAdded(\n        uint256 indexed reviewId,\n        bytes32 indexed productId,\n        address indexed reviewer,\n        uint8 rating,\n        string serviceName\n    );\n    event ReviewUpdated(uint256 indexed reviewId, string newContent);\n    event ReviewDeleted(uint256 indexed reviewId); // Note: Content is cleared, not deleted\n\n    /**\n     * @dev Constructor sets the initial owner of the contract.\n     */\n    constructor() Ownable(msg.sender) {}\n\n    /**\n     * @dev Adds a new review. Intended to be called only by the ReviewRegistry contract.\n     * @notice Checks for nullifier uniqueness before storing.\n     * @param productId ID of the product being reviewed.\n     * @param reviewerAddress Address of the user submitting the review.\n     * @param content Review text content.\n     * @param rating Numerical rating (1-5).\n     * @param nullifier Unique identifier from ZK proof (MUST be unique).\n     * @param serviceName Name of the service (e.g., \"Gumroad\", \"Luma\").\n     * @return The ID of the newly added review.\n     */\n    function addReview(\n        bytes32 productId,\n        address reviewerAddress, // Passed explicitly by ReviewRegistry\n        string calldata content,\n        uint8 rating,\n        bytes32 nullifier,\n        string calldata serviceName /* onlyReviewRegistry */\n    ) external returns (uint256) {\n        // Access Control Idea: Add a check `require(msg.sender == reviewRegistryAddress, \"Only registry allowed\");`\n        // if you deploy ReviewRegistry address immutably or add a setter function for it.\n        // For now, relying on the system design where only ReviewRegistry calls this.\n\n        require(\n            reviewerAddress != address(0),\n            \"Reviewer address cannot be zero\"\n        );\n        require(rating >= 1 && rating <= 5, \"Rating must be between 1 and 5\");\n\n        // --- Primary Nullifier Check ---\n        // Prevents the same proof/purchase from being used for multiple reviews via this contract.\n        require(!usedNullifiers[nullifier], \"Storage: Nullifier already used\");\n        usedNullifiers[nullifier] = true; // Mark as used immediately\n\n        // Increment review count and assign ID\n        reviewCount++;\n        uint256 newReviewId = reviewCount;\n\n        // Create and store the review\n        reviews[newReviewId] = Review({\n            id: newReviewId,\n            productId: productId,\n            reviewer: reviewerAddress, // Use the passed reviewer address\n            content: content,\n            rating: rating,\n            nullifier: nullifier,\n            timestamp: block.timestamp,\n            serviceName: serviceName\n        });\n\n        // Update lookup mappings\n        productReviews[productId].push(newReviewId);\n        reviewerReviews[reviewerAddress].push(newReviewId); // Use the passed reviewer address\n\n        // Emit event with correct reviewer address\n        emit ReviewAdded(\n            newReviewId,\n            productId,\n            reviewerAddress,\n            rating,\n            serviceName\n        );\n\n        return newReviewId;\n    }\n\n    /**\n     * @dev Retrieves a review by its ID.\n     * @param reviewId ID of the review to retrieve.\n     * @return id Review ID.\n     * @return productId Product ID.\n     * @return reviewer Address of the reviewer.\n     * @return content Review content.\n     * @return rating Review rating.\n     * @return timestamp Review timestamp.\n     * @return serviceName Name of the service.\n     */\n    function getReview(\n        uint256 reviewId\n    )\n        external\n        view\n        returns (\n            uint256 id,\n            bytes32 productId,\n            address reviewer,\n            string memory content,\n            uint8 rating,\n            uint256 timestamp,\n            string memory serviceName\n        )\n    {\n        require(reviewId > 0 && reviewId <= reviewCount, \"Invalid review ID\");\n        Review storage review = reviews[reviewId];\n        return (\n            review.id,\n            review.productId,\n            review.reviewer,\n            review.content,\n            review.rating,\n            review.timestamp,\n            review.serviceName\n        );\n    }\n\n    /**\n     * @dev Gets all review IDs for a specific product.\n     * @param productId ID of the product.\n     * @return Array of review IDs.\n     */\n    function getProductReviews(\n        bytes32 productId\n    ) external view returns (uint256[] memory) {\n        return productReviews[productId];\n    }\n\n    /**\n     * @dev Gets all review IDs submitted by a specific reviewer.\n     * @param reviewer Address of the reviewer.\n     * @return Array of review IDs.\n     */\n    function getReviewerReviews(\n        address reviewer\n    ) external view returns (uint256[] memory) {\n        return reviewerReviews[reviewer];\n    }\n\n    /**\n     * @dev Allows the original reviewer to update the content of their review.\n     * @param reviewId ID of the review to update.\n     * @param newContent New review content.\n     */\n    function updateReviewContent(\n        uint256 reviewId,\n        string calldata newContent\n    ) external {\n        require(reviewId > 0 && reviewId <= reviewCount, \"Invalid review ID\");\n        // Check against the stored reviewer address\n        require(\n            msg.sender == reviews[reviewId].reviewer,\n            \"Not the review owner\"\n        );\n\n        reviews[reviewId].content = newContent;\n        emit ReviewUpdated(reviewId, newContent);\n    }\n\n    /**\n     * @dev Allows the original reviewer or the contract owner to \"delete\" a review\n     *      by clearing its content. The review entry itself remains.\n     * @param reviewId ID of the review to delete.\n     */\n    function deleteReview(uint256 reviewId) external {\n        require(reviewId > 0 && reviewId <= reviewCount, \"Invalid review ID\");\n        require(\n            msg.sender == reviews[reviewId].reviewer || msg.sender == owner(),\n            \"Not authorized to delete\"\n        );\n\n        // Clear content instead of actual deletion to preserve history/ID sequence\n        reviews[reviewId].content = \"\";\n        // Consider clearing rating or adding a 'deleted' flag if needed elsewhere\n        // reviews[reviewId].rating = 0;\n\n        emit ReviewDeleted(reviewId);\n    }\n\n    /**\n     * @dev Public view function to check if a nullifier has been used.\n     *      Can be called by ReviewRegistry or external entities.\n     * @param _nullifier The nullifier to check.\n     * @return isUsed True if the nullifier exists in the usedNullifiers mapping.\n     */\n    function isNullifierUsed(\n        bytes32 _nullifier\n    ) external view returns (bool isUsed) {\n        return usedNullifiers[_nullifier];\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}